正则表达式的内容是一段存在于 / / 之间的特殊组合,它描述了一种字符串的匹配模式,可以用来检查一个字符串是否含有某个子串、可以将匹配的子串进行替换等.
正则表达式只能对字符串进行操作

语法：

```javascript
const reg = /正则表达式主体/修饰符(可选);

或者;

const reg = new RegExp("正则表达式主体", "修饰符(可选)");
```

&nbsp;

#### 字符串可以使用正则表达式的方法

- search()：该方法用于检索匹配的指定子字符串,若是找到,则返回该子字符串的下标,若是找不到,则返回-1;该方法不执行全局匹配，它将忽略标志`g`。它同时忽略 RegExp 的 `lastIndex`属性，并且总是从字符串的开始进行检索，这意味着它总是返回第一个满足匹配条件的目标的下标位置.

```javascript
const reg = /l/g;
"hello,world".search(reg); // 2
```

- match()：该方法用于检索字符串中指定的子字符串,它将匹配的结果存在一个数组中返回.若是未找到则返回 null;该方法会受到修饰符`g`的影响,若是声明全局修饰符`g`,则返回匹配到的所有,若是没有声明全局修饰符`g`,则返回查找匹配到的第一个.

```javascript
const reg = /l/g;
"hello,world".match(reg); // ["l","l","l"]
```

- replace()：方法用于正则匹配替换,它可以将符合匹配规则的字符替换为新的规定的字符;该方法也受到修饰符`g`的影响,若是声明全局修饰符`g`,则将进行全局匹配替换,若是没有声明全局修饰符`g`,则替换匹配到的第一个.

```javascript
const reg = /l/g;
"love,love,love,you!".replace(reg, "L"); // "Love,Love,Love,you!"
```

&nbsp;

#### 正则表达式主体声明 方括号[ ]

方括号用于声明查找指定范围内的字符

- /[abc]/ ：表示匹配 a b c 这三个字符中的任意

- /[^abc]/ ：表示不匹配 a b c 这三个字符中的任意

- /[a-z]/ ：表示匹配从 a 至 z 中的任意字符

- /[0-9]/ ：表示匹配从 0 至 9 中的任意数字

- /[A-Z]/ ：表示匹配从 大 A 至 大 Z 中的任意字符

- /[A-z]/ ：表示匹配从大 A 至 小 z 中的任意字符

- /(red|pink|blue)/ ：表示匹配圆括号中的 red,pink,blue 这三个单词中的任意一个

- ......

&nbsp;

#### 正则表达式主体声明 元字符

- ^ ：表示匹配以指定字符内容开头`const reg = /^a/; const reg2 = /^(abc)`

- `$` ：表示匹配以指定字符内容结尾`const reg = /c$/; const reg2 = /(ve)$`

- a | b ：表示匹配字符 a 或者字符 b.`const reg = /red|blue/`

- `.` ：表示匹配除换行符之外的任意单个字符`const reg = /./`

- \w ：表示匹配数字、字母、下划线
  `const reg = /\w/g`

- \W ：表示匹配非单词字符,它是`[^a-zA-Z_0-9]`的简写.`const reg = /\W/`

- \d ：表示匹配数字.它是`[0-9]`的简写.`const reg = /\d/`

- \D ：表示匹配非数字字符.它是`[^0-9]`的简写.`const reg = /\D/`

- \s ：表示匹配空白字符(空格符、制表符、回车符、换行符、垂直换行符、换页符).`const reg = /\s/`

- \S ：表示匹配非空白字符.`const reg = /\S/`

- \b ：表示匹配单词边界(即每个人单词组的头部和尾部,如 `hello23_`的单词边界就是 `hello23_`的最前面和最后面`.` 的位置 `.hello23_.`). `const reg = /\b/`

- \B ：表示匹配非单词边界`const reg = /\B/`

- \0 ：表示匹配 `NULL`字符. `const reg = /\0/`

- \n ：表示匹配换行符. `const reg = /\n/`

- \f ：表示匹配换页符. `const reg = /\f/`

- \r ：表示匹配回车符. `const reg = /\r/`

- \t ：表示匹配制表符. `const reg = /\t/`

- \v ：表示匹配垂直制表符. `const reg = /\v/`

- \A ：表示匹配字符串的开始`const reg = /\A/`

- \Z ：表示匹配字符串的结束`const reg = /\Z/`

- ......

&nbsp;

#### 正则表达式主体声明 量词

> 贪婪与非贪婪模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配

- {n} ：n 是一个正整数,表示匹配在{n}前面的一个字符刚好出现 n 次.`const reg = /c{2}/`

```javascript
const reg = /c{2}/;
reg.test("access"); // true
reg.test("click"); // false
```

- {n,} ：n 是一个正整数,表示匹配在{n,}前面的一个字符至少出现 n 次.`const reg = /l{2,}/`

```javascript
const reg = /l{n,}/;
reg.test("hello"); // true
reg.test("llly"); // true
reg.test("like"); //false
```

- {n,m} ：n 和 m 都是正整数,表示匹配在{n,m}前面的一个字符最少出现 n 次,最多出现 m 次,如果 n 或者 m 的值是 0,则这个值会被忽略.`const reg = /p{2,4}`

```javascript
const reg = /p{2,4}/;
reg.test("application"); // true
reg.test("fourpppp"); // true
reg.test("people"); // false
reg.test("fiveppppp"); // true
reg.test("pppppp"); // true
```

- ? ：表示匹配前面一个表达式 0 次或 1 次.即可有可无;如果紧跟在任何量词 `*`、 `+`、`?` 或 `{}` 的后面，将会使量词变为非贪婪（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反，例如，对 "123abc" 使用 /\d+/ 将会匹配 "123"，而使用 /\d+?/ 则只会匹配到 "1"。等价于`{0,1}`.`const reg = /ap?/`

```javascript
const reg = /e?le?/g;
"angel,angle,oslo".match(reg); // ["el", "le", "l"]
```

- `+` ：表示匹配前面一个表达式 1 次或者多次.等价于`{1,}`.`const reg = /ap+/`

```javascript
const reg = /ap+/;
"application".match(reg); // ["app", index: 0, input: "application", groups: undefined]
```

- `*` ：表示匹配前面一个表达式 0 次或者多次.等价于`{0,}`.`const reg = /ap*/`

```javascript
const reg = /ap*/;
"application".match(reg); // ["app", index: 0, input: "application", groups: undefined]
```

&nbsp;

#### 正则表达式主体声明 其他

- (x) ：表示匹配 'x' 并且记住匹配项。其中括号被称为捕获括号。`const reg = /(x)/`

- (?:x)：表示匹配 'x' 但是不记住匹配项。这种括号叫作非捕获括号，使得你能够定义与正则表达式运算符一起使用的子表达式.`const reg = /(?:x)/`

- x(?=y)：表示匹配'x'仅仅当'x'后面跟着'y'.这种叫做先行断言。`const reg = /x(?=y)/`

```javascript
const reg = /a(?=p)/;
"application".match(reg); // 因为a的后面跟着p,满足条件,所以会匹配到a
"ask".match(reg); // 因为a的后面没有跟着p,所以不匹配,返回null
```

- (?<=y)x：表示匹配'x'仅当'x'前面是'y'.这种叫做后行断言。`const reg = /(?<=y)x/`

```javascript
const reg = /(?<=v)e/;
"love".match(reg); // 因为e的前面是v,满足条件,所以可以将会匹配出e.
"blue".match(reg); // 因为e的前面不是v,不满足条件,因此不会匹配出e
```

- x(?!y)：表示仅仅当'x'后面不跟着'y'时匹配'x'，这被称为正向否定查找。`const reg = /x(?!y)/`

```javascript
const reg = /a(?!p)/;
"application".match(reg); // 因为a的后面紧跟着p.不满足条件.所以不会匹配出a.
"ask".match(reg); // 因为a的后面没有紧跟着p,因此满足条件,将会匹配出a.
```

- (?<!y)x：表示仅仅当'x'前面不是'y'时匹配'x'，这被称为反向否定查找。`const reg = /(?<!y)x/`

```javascript
const reg = /(?<!v)e/;
"love".match(reg); // 因为e的前面是v,因此不满足条件,不会匹配出e.
"blue".match(reg); // 因为e的前面不是v,因此满足条件,将会匹配出e
```
