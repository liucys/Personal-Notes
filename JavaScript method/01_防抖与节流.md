[TOC]

#### 防抖与节流的使用场景

防抖

- search 搜索,用户不断输入值时,用防抖来节约 http 请求(即：输入框 input 事件);
- window 触发 resize 时,不断的调整浏览器会不断触发该事件,可以用防抖来让其只触发最终的一次事件.

节流

- 鼠标的点击事件，比如 mousedown 只触发一次
- 监听滚动事件，比如是否滑到底部自动加载更多，用 throttle 判断
- 比如游戏中发射子弹的频率(1 秒发射一颗)

&nbsp;

#### 防抖

> 防抖即触发高频事件后的 n 秒内函数只会执行一次,如果 n 秒内高频事件再次被触发,则重新计算时间

- 思路：
  > 每次触发事件时都取消之前的延时调用方法

```js
function debounce(fn, delay) {
  // 创建一个定时标记
  let timer;
  return function (...args) {
    // 如果存在定时标记则清除定时器
    timer && clearTimeout(timer);
    // 设置新的定时器
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

const handleClick = debounce(function (name) {
  console.log("防抖");
  console.log(name);
}, 1000);

const searchTxt = document.querySelector(".search");
// 不需要传递参数时,防抖函数的调用
// searchTxt.addEventListener("input", handleClick);

// 需要传递参数时,防抖函数的调用
searchTxt.addEventListener("input", () => {
  handleClick("Hello,World");
});
```

&nbsp;

#### 节流

> 即高频事件触发,但是在 n 秒内只会执行一次。因此节流可以降低函数的执行频率。

- 思路：

> 每次触发事件时,都判断当前是否有等待执行的延时函数。

```js
function throttle(fn, delay) {
  let last = 0; // 上次触发时间
  return (...args) => {
    const now = Date.now();
    if (now - last > delay) {
      last = now;
      fn.apply(this, args);
    }
  };
}

const handleClick = throttle(function (name) {
  console.log("节流");
  console.log(name);
}, 2000);

// 不需要传递参数时,节流函数的调用
window.addEventListener("click", handleClick);

// 需要传递参数时,节流函数的调用
window.addEventListener("click", () => {
  handleClick({ label: "节流", value: "每2秒只触发一次" });
});
```
